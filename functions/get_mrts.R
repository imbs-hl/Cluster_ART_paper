#' select k most representative trees (MRTs) out of random forest (RF)
#' function should be used as algorithm when using batchtools (addAlgorithm())
#' @param data      parameter is needed because of use of batchtool package (package wants a parameter named "data"); parameter is not used anywhere, anything can by inserted
#' @param instance  output of problem generated by batchtools using addProblem() function, in this study it's generated with function in simulate_seifer.R
#' @param metric    metric to measure distances between trees in RF, has to be a metric from timbR package
#' @param k         number of MRTs to select
#' function returns: k most representative trees (MRTs)

get_mrts <- function(data, instance, metric, k, ...){

  # exctract data from instance
  information_df            <- instance[[1]]
  train_data                <- instance[[2]]
  test_data                 <- instance[[3]]
  effect_var_ids            <- instance[[4]]
  correlated_effect_var_ids <- instance[[5]]
  noise_var_ids             <- instance[[6]]
  rf                        <- instance[[7]]
  
  n_test <- nrow(test_data)
 
  # measure runtime
  start <- proc.time()
  
  # measure_distances on RF with specified metric using timbR package
  d  <- measure_distances(rf = rf, metric = metric)

  # select k MRTs
  mrts <- select_trees(rf = rf, num.trees = k, distance.matrix = d)
  
  # runtime in minutes
  end <- proc.time()
  runtime <- as.numeric((end - start)[1])/60
  
  # calculate quality measures

  # similarity: distance scores of ensembles of MRTs
  dist_variables <- measure_distances(rf = mrts, metric = "splitting variables") %>% mean()
  dist_weighted_variables <- measure_distances(rf = mrts, metric = "weighted splitting variables") %>% mean()
  
  # coverage: used effect variables
  covered_effect_vars <- lapply(c(1:k), function(tree){sum(effect_var_ids %in% treeInfo(mrts, tree)$splitvarName)/length(effect_var_ids)}) %>% unlist() %>% mean()
  
  # coverage: used correlated variables  
  covered_correlated_vars <- lapply(c(1:k), function(tree){sum(correlated_effect_var_ids %in% treeInfo(mrts, tree)$splitvarName)/length(correlated_effect_var_ids)}) %>% unlist() %>% mean()
  
  # coverage: used noise variables  
  covered_noise_vars <- lapply(c(1:k), function(tree){sum(noise_var_ids %in% treeInfo(mrts, tree)$splitvarName)/length(noise_var_ids)}) %>% unlist() %>% mean()
  
  # accuracy: prediction accuracy on test data set
  mse_test_dat_rf <- 1/nrow(test_data) * sum((test_data$y - predict(rf, data = test_data[,-1])$predictions)^2)
  mse_test_dat_mrt <- 1/nrow(test_data) * sum((test_data$y - predict(mrts, data = test_data[,-1])$predictions)^2)
  
  # fidelity: MSE to rf prediction
  mse_rf_pred <- 1/nrow(test_data) * sum((predict(rf, data = test_data[,-1])$predictions - predict(mrts, data = test_data[,-1])$predictions)^2)

  return(data.frame(metric                 = metric, 
                    method                      = "MRTs",
                    dist_variables              = dist_variables,
                    dist_weighted_variables     = dist_weighted_variables,
                    min_node_size               = information_df$min.node.size,
                    mse_test_dat_rf             = mse_test_dat_rf,
                    mse_test_dat_tree           = mse_test_dat_mrt,
                    mse_rf_pred                 = mse_rf_pred,
                    k_used                      = k,
                    covered_effect_vars         = covered_effect_vars,
                    covered_correlated_vars     = covered_correlated_vars,
                    covered_noise_vars          = covered_noise_vars,
                    runtime                     = runtime,
                    information_df,
                    imp.num.var = NA,
                    probs_quantiles = NA
                    )
  )
   
}

